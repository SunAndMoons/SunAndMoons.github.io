<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>虚函数</title>
    <link href="/2024/10/08/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    <url>/2024/10/08/%E8%99%9A%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h4><p>被 <code>virtual</code> 关键字修饰的成员函数</p><h4 id="为什么基类的构造函数不能定义为虚函数"><a href="#为什么基类的构造函数不能定义为虚函数" class="headerlink" title="为什么基类的构造函数不能定义为虚函数"></a>为什么基类的构造函数不能定义为虚函数</h4><p>虚函数的调用依赖于虚函数表，指向虚函数表的指针需要在构造函数中进行初始化，所以无法调用定义为虚函数的构造函数。</p><h4 id="什么基类的析构函数需要定义为虚函数"><a href="#什么基类的析构函数需要定义为虚函数" class="headerlink" title="什么基类的析构函数需要定义为虚函数"></a>什么基类的析构函数需要定义为虚函数</h4><p>为了实现动态绑定，基类指针指向派生类对象，如果析构函数不是虚函数，那么在对象销毁时，就是调用基类的析构函数，只能销毁派生类对象中的部分数据，所以必须将析构函数定义为虚函数。从而在对象销毁时，调用派生类的析构函数，从而销毁派生对象的所有数据。</p>]]></content>
    
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>野指针与悬挂指针</title>
    <link href="/2024/10/06/%E9%87%8E%E6%8C%87%E9%92%88%E4%B8%8E%E6%82%AC%E6%8C%82%E6%8C%87%E9%92%88/"/>
    <url>/2024/10/06/%E9%87%8E%E6%8C%87%E9%92%88%E4%B8%8E%E6%82%AC%E6%8C%82%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h4 id="c-中野指针和悬挂指针的区别"><a href="#c-中野指针和悬挂指针的区别" class="headerlink" title="c++中野指针和悬挂指针的区别"></a>c++中野指针和悬挂指针的区别</h4><p>两者都可能导致程序产生不可预测的行为，但有明显的区别。</p><ol><li><p>野指针：一种未被初始化的指针，通常会指向一个随机的内存地址。这个地址不可控，使用可能会导致程序崩溃或者数据损坏。</p></li><li><p>悬挂指针：一个原本合法的指针，但指向的内存已被释放或重新分配。当访问此指针指向的内存时，会导致未定义行为，因为那块内存数据可能已经不是期望的数据了。</p></li><li><p>如何避免野指针</p></li></ol><ul><li>初始化指针：在声明一个指针时，立刻初始化<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> *ptr=<span class="hljs-literal">nullptr</span>;<br></code></pre></td></tr></table></figure></li><li>使用智能指针：c++智能指针可以帮助自动管理指针的生命周期，减少手动管理的错误。</li></ul><ol start="4"><li>如何避免悬挂指针</li></ol><ul><li>在删除对象后，将指针设置为nullptr,确保指针不再指向已经释放的内存。</li><li>尽量使用智能指针，会自动处理指针的生命周期，减少悬挂指针的产生。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>智能指针</title>
    <link href="/2024/10/06/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <url>/2024/10/06/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍智能指针的使用场景"><a href="#介绍智能指针的使用场景" class="headerlink" title="介绍智能指针的使用场景"></a>介绍智能指针的使用场景</h4><p>c++中的智能指针主要用于管理动态分配的内存，避免内存泄漏。<br>c++11标准引入了三种主要的智能指针： <code>std::unique_ptr</code>、<code>std::shared_ptr</code>、<code>std::weak_ptr</code>。</p><h5 id="1-std-unique-ptr"><a href="#1-std-unique-ptr" class="headerlink" title="1. std::unique_ptr"></a>1. std::unique_ptr</h5><p>独占所有权的智能指针，同一时间内只能有一个 <code>unique_ptr</code> 指向一个特定的对象，当<code>unique_ptr</code>被销毁时，它所指向的对象也会被销毁。</p><h6 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h6><p>需要确保一个对象只被一个指针所拥有时；<br>自动管理资源，如文件句柄或者互斥锁时。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>()&#123;&#125;<br>    ~<span class="hljs-built_in">Test</span>()&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::unique_ptr&lt;Test&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Test())</span></span>;<br>    ptr-&gt;<span class="hljs-built_in">test</span>();<br>    <span class="hljs-comment">//当ptr离开作用域时，指向的对象也会被销毁。</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-std-shared-ptr"><a href="#2-std-shared-ptr" class="headerlink" title="2.std::shared_ptr"></a>2.std::shared_ptr</h5><p>共享所有权的智能指针，多个<code>shared_ptr</code> 可以指向同一个对象。其内部使用引用计数确保只有当最后一个指向对象的 <code>shared_ptr</code>被销毁时，对象才销毁。</p><h6 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h6><p>多个所有者之间共享对象时；<br>需要通过复制构造函数或者赋值操作符来复制智能指针时；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::shared_ptr&lt;Test&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Test())</span></span>;<br>    std::shared_ptr&lt;Test&gt; ptr2=ptr1;<br>    ptr1-&gt;<span class="hljs-built_in">test</span>();<br>    <span class="hljs-comment">//当ptr1和ptr2离开作用域时，他们指向的对象会被销毁</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-std-weak-ptr"><a href="#3-std-weak-ptr" class="headerlink" title="3. std::weak_ptr"></a>3. std::weak_ptr</h5><p>不拥有对象所有权的智能指针，指向一个由std::shared_ptr管理的对象，用于解决shared_ptr之间循环引用的问题。</p><h6 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h6><p>需要访问但不拥有有shared_ptr管理的对象时；<br>解决shared_ptr 的循环引用问题时；<br>weak_ptr 和shared_ptr 需要搭配使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::shared_ptr&lt;Test&gt; <span class="hljs-title">sharedPtr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Test())</span></span>;<br>    std::weak_ptr&lt;Test&gt; weakptr=sharedPtr;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">auto</span> lockedsharedptr= weakptr.<span class="hljs-built_in">lock</span>())&#123;<br>        lockedsharedptr-&gt;<span class="hljs-built_in">test</span>();<br>    &#125;<br>    <span class="hljs-comment">//shared_ptr离开作用域时，指向的对象会自动销毁</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>weakptr.lock() 方法尝试从其所关联的shared_ptr创建一个实例，如果袁术的shared_ptr 仍然存在(管理的对象还没被销毁)， lock() 方法会成功返回一个指向该对象的shared_ptr。如果原始的shared_ptr已经被销毁，lock()会返回一个空的shared_ptr。</p><h6 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h6><ol><li>尽量使用智能指针来管理内存；</li><li>如果没有多个所有者共享对象的需求，建议优先使用unique_ptr管理内存，相对于 shared_ptr更轻量；</li><li>在使用shared_ptr时，一定要注意是否有循环引用的问题，会导致内存泄漏；</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>move</title>
    <link href="/2024/10/06/move/"/>
    <url>/2024/10/06/move/</url>
    
    <content type="html"><![CDATA[<h5 id="c-中move有什么作用，原理是什么"><a href="#c-中move有什么作用，原理是什么" class="headerlink" title="c++中move有什么作用，原理是什么"></a>c++中move有什么作用，原理是什么</h5><p>move 是c++11引入的一个新特性，用来实现移动语义。主要作用是将对象的资源从一个对象转移到另一个对象，而无需进行深拷贝，减少了资源内存的分配，可以提高性能。</p><h6 id="1）move-转换成右值有什么好处"><a href="#1）move-转换成右值有什么好处" class="headerlink" title="1）move 转换成右值有什么好处"></a>1）move 转换成右值有什么好处</h6><p>右值可以出发移动语义。移动语义：可以理解为在对象转换的时候，通过右值可以触发到类的移动构造函数或者移动赋值函数。<br>因为出发了移动构造函数或者移动赋值函数，默认原对象不会再使用了，包括某些内存。这样我们可以在新对象中直接使用原对象的那部分内存，减少了数据的拷贝操作，昂贵的拷贝转换为了廉价的移动，提升了程序的性能。</p><h6 id="2）std-move-后的对象还能够使用吗？"><a href="#2）std-move-后的对象还能够使用吗？" class="headerlink" title="2）std::move 后的对象还能够使用吗？"></a>2）std::move 后的对象还能够使用吗？</h6><p>取决于搭配的移动构造函数和移动赋值构造函数时如何实现的。如果在上述两个函数中，还是使用了拷贝的动作，那原对象还是可以使用的。<br>能够使用的示例代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>()&#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;A()&quot;</span>&lt;&lt;std::endl;<br>    &#125;<br>    ~<span class="hljs-built_in">A</span>()&#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;~A()&quot;</span>&lt;&lt;std::endl;<br>    &#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; a)&#123;<br>        count_=a.count_;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;A copy&quot;</span>&lt;&lt;std::endl;<br>    &#125;<br>    A&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> A&amp; a)&#123;<br>        count_=a.count_;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;A=&quot;</span>&lt;&lt;std::endl;<br>    &#125;<br>    <span class="hljs-built_in">A</span>(A&amp;&amp; a)&#123;<br>        count_=a.count_;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;A move&quot;</span>&lt;&lt;std::endl;<br>    &#125;<br>    A&amp; <span class="hljs-keyword">operator</span>=(A&amp;&amp;a)&#123;<br>        count_=a.count_;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;A move =&quot;</span>&lt;&lt;std::endl;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br><br>    &#125;<br>    std::string count_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A a;<br>    a.count_=<span class="hljs-string">&quot;12345&quot;</span>;<br>    A b=std::<span class="hljs-built_in">move</span>(a);<br>    std::cout&lt;&lt;a.count_&lt;&lt;std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果在移动构造函数和移动赋值函数中，将原对象的内存废弃掉，新对象使用原对象的内存，那原对象的内存就不可以使用了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">A</span>(A&amp;&amp;a)<br>&#123;<br>    count_=std::<span class="hljs-built_in">move</span>(a.count_);<br>&#125;<br>A&amp; <span class="hljs-keyword">operator</span>=(A&amp;&amp; a)<br>&#123;<br>    count_=std::<span class="hljs-built_in">move</span>(a.count_);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><ol><li>std::move 函数的作用是将参数强制转换为右值，只是转换为右值，不会对对象进行任何操作。</li><li>转换右值可以触发移动语义，减少数据的拷贝操作，提升程序的性能。</li><li>在使用std::move 函数后，原对象是否可以继续使用取决于移动构造函数和移动赋值函数的实现。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>左值与右值</title>
    <link href="/2024/10/06/%E5%B7%A6%E5%80%BC%E4%B8%8E%E5%8F%B3%E5%80%BC/"/>
    <url>/2024/10/06/%E5%B7%A6%E5%80%BC%E4%B8%8E%E5%8F%B3%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h5 id="什么是左值，什么是右值"><a href="#什么是左值，什么是右值" class="headerlink" title="什么是左值，什么是右值"></a>什么是左值，什么是右值</h5><p><strong>左值</strong>：可以出现在赋值运算符的左边，并且可以被取地址，通常是有名字的变量。<br><strong>右值</strong>: 不能出现在赋值运算符的左边，不可以被取地址， 表示一个具体的数据值，通常是常量、临时变量。</p><p><strong>区分</strong>： </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">左值：可以放在等号左边的值<br>右值：不可以放在等号左边的值<br><br>左值：可以被取地址并且有名字的值<br>右值：不能取地址的没有名字的<br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a=b+c；<br></code></pre></td></tr></table></figure><p>a 是左值，有变量名，可以取地址，也可以放在等号左边；<br>a+b 是右值，没有名字且不能取地址， &amp;（b+c） 不能通过编译，并且也不能放在等号左边。</p><p><strong>左值引用</strong>：等号右边的值必须可以取地址，如果不能取地址，会编译失败。或者可以使用const引用形式，但是只能通过引用读取输出，不能修改，因为是常量引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a=<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> &amp;b=a;<span class="hljs-comment">//b 是左值引用</span><br>b=<span class="hljs-number">4</span>;<br><span class="hljs-type">int</span> &amp;c=<span class="hljs-number">10</span>；<span class="hljs-comment">//error, 10无法取地址，无法进行引用</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;d=<span class="hljs-number">10</span>；<span class="hljs-comment">//ok,因为是常量引用，引用常数字，会存储在内存中，可以取地址</span><br></code></pre></td></tr></table></figure><p><strong>右值引用</strong><br>可以理解为对右值的引用，即对一个临时对象或者即将销毁的对象的引用，开发者可以利用这些临时对象，却不需要复制他们。<br>如果使用右值引用，那表达式右边的值需要时右值，可以使用std::move 函数强制将左值转换为右值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a=<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> &amp;&amp;b=a;<span class="hljs-comment">//error a是左值</span><br><span class="hljs-type">int</span> &amp;&amp;c=std:<span class="hljs-built_in">move</span>(a);<br></code></pre></td></tr></table></figure><p><strong>左值引用和右值引用的使用场景</strong><br>左值引用：当需要修改对象的值，或者需要引用一个持久对象时使用；<br>右值引用：当需要处理一个临时对象，并且想要避免复制，或者实现移动语义时使用。</p><p><strong>纯右值</strong><br>运算表达式产生的临时变量，不和对象关联的原始字面量，非引用返回的临时变量、lamba表达式等都是纯右值。<br><strong>将亡值</strong><br>c++11 新增的和右值引用相关的表达式，通常指将要被移动的对象，T&amp;&amp;函数的返回值，std::move 函数的返回值、转换为T&amp;&amp;类型转换函数的返回值。</p><p>将亡值可以了理解为将要销毁的值，通过“盗取”其他变量内存空间方式获取的值，在确保其他变量不再被使用或者即将销毁时，可以避免内存空间的释放和分配、延长变量值的生命周期，常用来完成移动构造或者移动复制的特殊任务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;&#125;;<br>A a;<br><span class="hljs-keyword">auto</span> c=std::<span class="hljs-built_in">move</span>(a);<span class="hljs-comment">//std::move(a)是将亡值</span><br><span class="hljs-keyword">auto</span> d= <span class="hljs-built_in">static_cast</span>&lt;A&amp;&amp;&gt;(a);<span class="hljs-comment">//static_cast&lt;A&amp;&amp;&gt;（a） 是将亡值。</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
