<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>osm地图格式</title>
    <link href="/2024/11/08/osm%E5%9C%B0%E5%9B%BE%E6%A0%BC%E5%BC%8F/"/>
    <url>/2024/11/08/osm%E5%9C%B0%E5%9B%BE%E6%A0%BC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><strong>数据下载</strong></p><p><a href="http://download.geofabrik.de/asia/china-latest-free.shp.zip">http://download.geofabrik.de/asia/china-latest-free.shp.zip</a></p><p><strong>文档说明</strong></p><p><a href="http://download.geofabrik.de/osm-data-in-gis-formats-free.pdf">http://download.geofabrik.de/osm-data-in-gis-formats-free.pdf</a></p><p>Geofabrik also makes extended shapefiles to order; please see<br><a href="http://www.geofabrik.de/data/shapefiles.html">http://www.geofabrik.de/data/shapefiles.html</a> for details and example<br>downloads.</p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h4><h5 id="1-1-坐标"><a href="#1-1-坐标" class="headerlink" title="1.1 坐标"></a>1.1 坐标</h5><p>所有坐标都是wgs84坐标</p><h5 id="1-2-编码"><a href="#1-2-编码" class="headerlink" title="1.2 编码"></a>1.2 编码</h5><p>utf-8</p><h5 id="1-3-attribute-names"><a href="#1-3-attribute-names" class="headerlink" title="1.3 attribute names"></a>1.3 attribute names</h5><p>小写，且长度&lt;11</p><h5 id="1-4-common-attributes"><a href="#1-4-common-attributes" class="headerlink" title="1.4 common attributes"></a>1.4 common attributes</h5><table><thead><tr><th>attribute</th><th>type</th><th>desctiption</th></tr></thead><tbody><tr><td>id</td><td>varchar (4bytes)</td><td>标识当前layer</td></tr><tr><td>osm_id</td><td>varchar (10)</td><td>OSM DB中的ID</td></tr><tr><td>code</td><td>smallint(2bytes)</td><td></td></tr><tr><td>fclass</td><td>varchar (40)</td><td></td></tr><tr><td>name</td><td>varchar (100)</td><td>街道名|地名</td></tr><tr><td><strong>code</strong>、<strong>fclass</strong>、<strong>name</strong> 经常包含同样的信息</td><td></td><td></td></tr></tbody></table><h5 id="1-5-Points-and-areas"><a href="#1-5-Points-and-areas" class="headerlink" title="1.5 Points and areas"></a>1.5 Points and areas</h5><p>文件名称： _a : 表示的是区域； 其他的文件中为：line 或者point</p><h5 id="1-6-spillover-shape-files"><a href="#1-6-spillover-shape-files" class="headerlink" title="1.6 spillover shape files"></a>1.6 spillover shape files</h5><p>如果osm_pois_v07_1.shp  文件大于2G， 存储到 <em>osm_pois_v07_2.shp</em> 中，以此类推。</p><h4 id="2-Feature-catalogue"><a href="#2-Feature-catalogue" class="headerlink" title="2. Feature catalogue"></a>2. Feature catalogue</h4><table><thead><tr><th>Geometry</th><th>code</th><th>layer</th><th>description</th></tr></thead><tbody><tr><td>Point</td><td></td><td></td><td></td></tr><tr><td></td><td>10XX</td><td>places</td><td>cities、town、suburbs、villages</td></tr><tr><td></td><td>2XXX</td><td>pois</td><td></td></tr><tr><td></td><td>20XX</td><td></td><td>公共设施：政府办共等</td></tr><tr><td></td><td>21XX</td><td></td><td>医院</td></tr><tr><td></td><td>22XX</td><td></td><td>公园等</td></tr><tr><td></td><td>23XX</td><td></td><td>饭店、酒馆、咖啡等</td></tr><tr><td></td><td>24XX</td><td></td><td>旅馆、晚上休息的地方</td></tr><tr><td></td><td>25XX</td><td></td><td>超市、菜市场</td></tr><tr><td></td><td>26XX</td><td></td><td>银行</td></tr><tr><td></td><td>27Xx</td><td></td><td>旅行景点、博物馆</td></tr><tr><td></td><td>29XX</td><td></td><td>其他</td></tr><tr><td></td><td>3XXX</td><td>pofw</td><td>礼拜场所：教堂、清真寺等</td></tr><tr><td></td><td>41XX</td><td>natural</td><td>自然</td></tr><tr><td></td><td>52XX</td><td>traffic</td><td>信号灯等，需要具体看数据</td></tr><tr><td></td><td>50XX</td><td>transport</td><td>加油站等，需要具体看数据</td></tr><tr><td>Line</td><td></td><td></td><td></td></tr><tr><td></td><td>51XX</td><td>roads</td><td>道路的数据</td></tr><tr><td></td><td>61XX</td><td>railway</td><td>铁路、地铁、轻轨等</td></tr><tr><td></td><td>81XX</td><td>waterways</td><td>运河</td></tr><tr><td>Polygon</td><td></td><td></td><td></td></tr><tr><td></td><td>15XX</td><td>buildings</td><td></td></tr><tr><td></td><td>72xx</td><td>landuse</td><td>雨林、住宅区、工业区</td></tr><tr><td></td><td>82XX</td><td>water</td><td>湖</td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><h4 id="3-Point"><a href="#3-Point" class="headerlink" title="3. Point"></a>3. Point</h4><h5 id="3-1-place"><a href="#3-1-place" class="headerlink" title="3.1 place"></a>3.1 place</h5><p>代表city、town的位置，通常是中心的某个位置。</p><p><strong>附加属性</strong></p><p>population: int,人口数量。不可用时&#x3D;0。比如岛。</p><h5 id="3-2-traffic"><a href="#3-2-traffic" class="headerlink" title="3.2 traffic"></a>3.2 traffic</h5><table><thead><tr><th>code</th><th>fclass</th><th>description</th></tr></thead><tbody><tr><td>5201</td><td>traffic_signals</td><td>交通信号灯</td></tr><tr><td>5202</td><td>mini_roundabout</td><td>没有物理结构的小环岛</td></tr><tr><td>5203</td><td>stop</td><td>stop sign</td></tr><tr><td>5204</td><td>crossing</td><td>人行道</td></tr><tr><td>5208</td><td>speed_camera</td><td>电子限速机</td></tr><tr><td>5251</td><td>service</td><td>SA 服务区</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h5 id="3-3-Transport-Infrastructure"><a href="#3-3-Transport-Infrastructure" class="headerlink" title="3.3 Transport Infrastructure"></a>3.3 Transport Infrastructure</h5><p>交通基础设施</p><h4 id="4-Line"><a href="#4-Line" class="headerlink" title="4. Line"></a>4. Line</h4><h5 id="4-1-roads"><a href="#4-1-roads" class="headerlink" title="4.1 roads"></a>4.1 roads</h5><p><strong>附加属性</strong></p><table><thead><tr><th>attribute</th><th>type</th><th>desription</th></tr></thead><tbody><tr><td>ref</td><td>VARCHAR(20)</td><td>道路的参考标号：</td></tr><tr><td>oneway</td><td>VARCHAR(1)</td><td>T: 逆向，F:正向；B:双向</td></tr><tr><td>maxspeed</td><td>samllint</td><td>最大限速 km&#x2F;h</td></tr><tr><td>layer</td><td></td><td></td></tr><tr><td>bridge</td><td></td><td>T|F</td></tr><tr><td>tunnel</td><td></td><td>T|F</td></tr><tr><td></td><td></td><td></td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>opendrive</title>
    <link href="/2024/11/07/opendrive/"/>
    <url>/2024/11/07/opendrive/</url>
    
    <content type="html"><![CDATA[<h4 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h4><p>ASAM OpenDrive 描述驾驶仿真应用所需的<strong>静态</strong>道路交通网络（路网），并提供了标准交换格式的说明文档。</p><p>对道路以及道路上的物体进行表述，道路、查到、交叉路口等内容进行建模。</p><p>使用文件扩展名为 <em>.xord</em>  xml文件作为描述路网的基础。通过 node 被构建，用户可自定义数据扩展结点。</p><h5 id="1-1-单位"><a href="#1-1-单位" class="headerlink" title="1.1 单位"></a>1.1 单位</h5><p>若没有特殊说明，所有数据采用SI单位：</p><ul><li>length: [m]</li><li>angle:[rad]</li><li>time:[s]</li><li>speed: [m&#x2F;s]</li></ul><h5 id="1-2-曲率"><a href="#1-2-曲率" class="headerlink" title="1.2 曲率"></a>1.2 曲率</h5><p>​曲率&#x3D; 1&#x2F;曲率半径</p><ul><li>正曲率：左曲线（逆时针运动）</li><li>负曲率：右曲线（顺时针运动）</li></ul><h4 id="2-通用架构"><a href="#2-通用架构" class="headerlink" title="2. 通用架构"></a>2. 通用架构</h4><h5 id="2-1-文件结构"><a href="#2-1-文件结构" class="headerlink" title="2.1 文件结构"></a>2.1 文件结构</h5><p>数据存储在XML文件中，文件扩展名为 <em>.xord</em>， 压缩文件的扩展名为 <em>.xordz</em>。</p><h5 id="2-2-头文件"><a href="#2-2-头文件" class="headerlink" title="2.2 头文件"></a>2.2 头文件</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">header</span> <span class="hljs-attr">revMajor</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">revMinor</span>=<span class="hljs-string">&quot;4&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;1.00&quot;</span> <span class="hljs-attr">date</span>=<span class="hljs-string">&quot;Thu Dec 10 10:35:57 2009&quot;</span> <span class="hljs-attr">north</span>=<span class="hljs-string">&quot;0.0000000000000000e+00&quot;</span> <span class="hljs-attr">south</span>=<span class="hljs-string">&quot;0.0000000000000000e+00&quot;</span> <span class="hljs-attr">east</span>=<span class="hljs-string">&quot;0.0000000000000000e+00&quot;</span> <span class="hljs-attr">west</span>=<span class="hljs-string">&quot;0.0000000000000000e+00&quot;</span> <span class="hljs-attr">maxRoad</span>=<span class="hljs-string">&quot;517&quot;</span> <span class="hljs-attr">maxJunc</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">maxPrg</span>=<span class="hljs-string">&quot;0&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>名称</th><th>类型</th><th>单位</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>revMajor</td><td>ushort</td><td>-</td><td>1</td><td>格式主版本号</td></tr><tr><td>revMinor</td><td>ushort</td><td>-</td><td>4</td><td>格式次版本号</td></tr><tr><td>name</td><td>string</td><td>-</td><td>-</td><td>数据库名称</td></tr><tr><td>version</td><td>string</td><td>-</td><td>-</td><td>本路网的版本号</td></tr><tr><td>date</td><td>string</td><td>-</td><td>-</td><td>数据库创建的时间</td></tr><tr><td>north</td><td>double</td><td>m</td><td>-</td><td>最大惯性y值</td></tr><tr><td>south</td><td>double</td><td>m</td><td>-</td><td>最小惯性y值</td></tr><tr><td>east</td><td>double</td><td>m</td><td>-</td><td>最大惯性x值</td></tr><tr><td>west</td><td>double</td><td>m</td><td>-</td><td>最小惯性x值</td></tr><tr><td>vendor</td><td>string</td><td>-</td><td>-</td><td>开发商名称</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h4 id="3-坐标系"><a href="#3-坐标系" class="headerlink" title="3. 坐标系"></a>3. 坐标系</h4><p>OPENDRIVE 使用三种类型的坐标系。</p><ul><li><p>惯性x&#x2F;y&#x2F;z轴坐标系</p></li><li><p>参考线s&#x2F;t&#x2F;h轴坐标系</p></li><li><p>局部u&#x2F;v&#x2F;z轴坐标系</p><p><img src="/images/coo_sys_overview.png" alt="image-coo_sys_overview"></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Gis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux</title>
    <link href="/2024/11/05/linux/"/>
    <url>/2024/11/05/linux/</url>
    
    <content type="html"><![CDATA[<h6 id="1-显示所有包含关键字的进程"><a href="#1-显示所有包含关键字的进程" class="headerlink" title="1.显示所有包含关键字的进程"></a>1.显示所有包含关键字的进程</h6><p>管道符 “|” 用来隔开两个命令，管道符左边命令的输出会作为管道符右边命令的输入;</p><p>grep 命令用来查找文件里符合条件的字符串或正则表达式</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ps -ef | grep XXX<br></code></pre></td></tr></table></figure><h6 id="2-kill"><a href="#2-kill" class="headerlink" title="2. kill"></a>2. kill</h6><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">kill</span> pid<br><span class="hljs-built_in">kill</span> -9 pid //强制杀死<br></code></pre></td></tr></table></figure><h6 id="3-ip相关"><a href="#3-ip相关" class="headerlink" title="3.ip相关"></a>3.ip相关</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">//install<br>apt-get install net-tools<br>//获取IP地址<br>ip addr<br><br>//只获取IP地址<br>ip addr | grep <span class="hljs-string">&#x27;inet &#x27;</span> | grep -v <span class="hljs-string">&#x27;127.0.0.1&#x27;</span> | awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span> | <span class="hljs-built_in">cut</span> -f1 -d<span class="hljs-string">&#x27;/&#x27;</span><br><br></code></pre></td></tr></table></figure><h6 id="4-tar"><a href="#4-tar" class="headerlink" title="4.tar"></a>4.tar</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">//将 .tar.gz 文件解压缩到不同的工作目录<br>tar -xvf /tmp/mapdata.tar.gz -C /userdata/map/mapdata<br></code></pre></td></tr></table></figure><h5 id="5-cmake"><a href="#5-cmake" class="headerlink" title="5.cmake"></a>5.cmake</h5><p>安装boost库</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs q">sudo apt-<span class="hljs-built_in">get</span> install libboost-<span class="hljs-built_in">all</span>-<span class="hljs-built_in">dev</span> -y<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cmake</title>
    <link href="/2024/11/05/cmake/"/>
    <url>/2024/11/05/cmake/</url>
    
    <content type="html"><![CDATA[<h6 id="0-其他"><a href="#0-其他" class="headerlink" title="0. 其他"></a>0. 其他</h6><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake">cmake_minimun_required(VERSION <span class="hljs-number">2.8</span>);//最小版本：目前全部删除<br><span class="hljs-keyword">include_directories</span>(<span class="hljs-string">&quot;$&#123; CMAKE_CURRENT_SOURCE_DIR&#125;/../NisToolCommon/include&quot;</span>);//设置包含的目录<br><span class="hljs-keyword">set</span>();//追加变量的值<br>//添加链接的库 <br></code></pre></td></tr></table></figure><h6 id="1-添加boost库"><a href="#1-添加boost库" class="headerlink" title="1.添加boost库"></a>1.添加boost库</h6><p>linux 安装boost 库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install libboost-all-dev -y<br></code></pre></td></tr></table></figure><p>cmake</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">find_package</span>(Boost COMPONENTS regex system REQUIRED)<br><span class="hljs-keyword">if</span>(Boost_FOUND)<br>    <span class="hljs-keyword">MESSAGE</span>( STATUS <span class="hljs-string">&quot;Boost_INCLUDE_DIRS = $&#123;Boost_INCLUDE_DIRS&#125;.&quot;</span>)<br>    <span class="hljs-keyword">MESSAGE</span>( STATUS <span class="hljs-string">&quot;Boost_LIBRARIES = $&#123;Boost_LIBRARIES&#125;.&quot;</span>)<br>    <span class="hljs-keyword">MESSAGE</span>( STATUS <span class="hljs-string">&quot;Boost_LIB_VERSION = $&#123;Boost_LIB_VERSION&#125;.&quot;</span>)<br>    <span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;Boost_INCLUDE_DIRS&#125;</span>)<br><br><span class="hljs-keyword">endif</span>()<br><span class="hljs-keyword">target_link_libraries</span>(<span class="hljs-variable">$&#123;MODULE_NAME&#125;</span> <span class="hljs-variable">$&#123;Boost_LIBRARIES&#125;</span> )<br></code></pre></td></tr></table></figure><p>target_link_libraries 是cmake 用于指定目标以来的库函数，可以链接静态库、动态库和共享库；</p><p>可以使用find_package函数查找库的路径</p><p>在编译的时候遇到问题：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">/usr/bin/ld: CMakeFiles/LearnCmake.dir/src/hello.cpp.o: in function `boost::asio::detail::posix_thread::~posix_thread()&#x27;:<br>hello.cpp:(.text._ZN5boost4asio6detail12posix_threadD2Ev[_ZN5boost4asio6detail12posix_threadD5Ev]+0x2a): undefined reference to `pthread_detach&#x27;<br>/usr/bin/ld: CMakeFiles/LearnCmake.dir/src/hello.cpp.o: in function `boost::asio::detail::posix_thread::join()&#x27;:<br>hello.cpp:(.text._ZN5boost4asio6detail12posix_thread4joinEv[_ZN5boost4asio6detail12posix_thread4joinEv]+0x2f): undefined reference to `pthread_join&#x27;<br><br></code></pre></td></tr></table></figure><p>解决方法: 在链接的时候 增加 <em>-lphread</em> 选项</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target_link_libraries</span>(<span class="hljs-variable">$&#123;MODULE_NAME&#125;</span> <span class="hljs-variable">$&#123;Boost_LIBRARIES&#125;</span>)<br><span class="hljs-keyword">target_link_libraries</span>(<span class="hljs-variable">$&#123;MODULE_NAME&#125;</span> <span class="hljs-variable">$&#123;Boost_LIBRARIES&#125;</span>  -lpthread)<br></code></pre></td></tr></table></figure><h6 id="2-标准选项"><a href="#2-标准选项" class="headerlink" title="2.标准选项"></a>2.标准选项</h6><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tex">-DCMAKE<span class="hljs-built_in">_</span>BUILD<span class="hljs-built_in">_</span>TYPE= 从Release、RelWithDebInfo、Debug或者可能存在的更多参数中选择。<br><br>-DCMAKE<span class="hljs-built_in">_</span>INSTALL<span class="hljs-built_in">_</span>PREFIX= 这是安装位置。UNIX 系统默认的位置是 /usr/local，用户目录是 ~/.local，也可以是你自己指定的文件夹。<br><br>-DBUILD<span class="hljs-built_in">_</span>SHARED<span class="hljs-built_in">_</span>LIBS= 你可以把这里设置为 ON 或 OFF 来控制共享库的默认值（不过，你也可以明确选择其他值而不是默认值）<br><br>-DBUILD<span class="hljs-built_in">_</span>TESTING= 这是启用测试的通用名称，当然不会所有软件包都会使用它，有时这样做确实不错。<br></code></pre></td></tr></table></figure><h6 id="3-版本"><a href="#3-版本" class="headerlink" title="3.版本"></a>3.版本</h6><p>如果cmake 版本低于3.12 ,cmake将会被设置为当前版本;如果cmake 版本是3.12 或者更高，将会遵循 cmake_minimum_required 中的规定，程序将继续正常进行。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.1</span>)<br><span class="hljs-keyword">if</span>(<span class="hljs-variable">$&#123;CMAKE_VERSION&#125;</span> <span class="hljs-keyword">VERSION_LESS</span> <span class="hljs-number">3.12</span>)<br><span class="hljs-keyword">cmake_policy</span>(VERSION <span class="hljs-variable">$&#123;CMAKE_MAJOR_VERSION&#125;</span>.<span class="hljs-variable">$&#123;CMAKE_MINOR_VERSION&#125;</span>)<br><span class="hljs-keyword">endif</span>()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>cmake</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2024/11/05/git/"/>
    <url>/2024/11/05/git/</url>
    
    <content type="html"><![CDATA[<h6 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span>  --recursive //递归的方式克隆整个项目, 包含子项目<br>git submodule add   //添加子模块<br>git submodule init //初始化子模块<br>git submodule update //更新子模块<br>git submodule foreach git pull //拉取所有子模块<br></code></pre></td></tr></table></figure><h6 id="查看所有分支"><a href="#查看所有分支" class="headerlink" title="查看所有分支"></a>查看所有分支</h6><p><code>git branch -a</code></p><h6 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h6><p><code>git branch L2Map_New_RampAssist</code></p><h6 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h6><p><code>git checkout L2Map_New_RampAssist</code></p><h6 id="创建-切换分支"><a href="#创建-切换分支" class="headerlink" title="创建+切换分支"></a>创建+切换分支</h6><p><code>git checkout -b L2Map_New_RampAssist</code></p><h5 id="将本地分支同步到远程"><a href="#将本地分支同步到远程" class="headerlink" title="将本地分支同步到远程"></a>将本地分支同步到远程</h5><p><code>git push origin L2Map_New_RampAssist:L2Map_New_RampAssist</code></p><h6 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h6><p><code>git push origin -d branch_name</code></p><h6 id="所有子模块切换到master分支"><a href="#所有子模块切换到master分支" class="headerlink" title="所有子模块切换到master分支"></a>所有子模块切换到master分支</h6><p><code>git submodule foreach git checkout master </code></p><h6 id="添加submodel"><a href="#添加submodel" class="headerlink" title="添加submodel"></a>添加submodel</h6><ol><li>clone 代码，生成文件夹</li><li>在代码的最外层</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull <br>git submodule add git@gitlab.navinfo.com:compiler/sdpro_mmt/sdpro_mmt_makeobjectdata.git ./compiler/SDPro_MMT/SDPro_MMT_MakeObjectData <br><br></code></pre></td></tr></table></figure><h6 id="clone-使用https"><a href="#clone-使用https" class="headerlink" title="clone 使用https"></a>clone 使用https</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global --<span class="hljs-built_in">unset</span> http.proxy<br>git config --global --<span class="hljs-built_in">unset</span> https.proy<br></code></pre></td></tr></table></figure><h6 id="Clone指定版本代码"><a href="#Clone指定版本代码" class="headerlink" title="Clone指定版本代码"></a>Clone指定版本代码</h6><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> checkout 版本号<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>地图了解</title>
    <link href="/2024/11/05/%E5%9C%B0%E5%9B%BE%E5%86%85%E5%AE%B9%E5%8F%8A%E4%BD%BF%E7%94%A8%E4%BA%86%E8%A7%A3/"/>
    <url>/2024/11/05/%E5%9C%B0%E5%9B%BE%E5%86%85%E5%AE%B9%E5%8F%8A%E4%BD%BF%E7%94%A8%E4%BA%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h6 id="ACC算法"><a href="#ACC算法" class="headerlink" title="ACC算法"></a>ACC算法</h6><p>ACC是<strong>自适应巡航控制</strong>（Adaptive Cruise Control）的缩写，是自动驾驶系统中的一个重要算法。ACC通过使用传感器来感知前方车辆的距离和速度，并根据这些信息自动调整车辆的速度，以保持与前车的安全距离。ACC可以根据交通状况自动加速和减速，从而提高驾驶的舒适性和安全性。ACC算法通常使用车辆间距离和速度的控制模型来计算适当的加速度和减速度。</p><h6 id="Headway类型"><a href="#Headway类型" class="headerlink" title="Headway类型"></a>Headway类型</h6><p>在自动驾驶中，Headway类型是指车辆之间的车头间距类型。车头间距是指车辆前方与前车之间的距离。Headway类型可以分为固定间距和可变间距两种。</p><p>固定间距是指自动驾驶系统在跟随前车时，保持固定的车头间距。这种类型的车头间距可以根据道路条件和车速进行调整，但在跟随过程中保持不变。</p><p>可变间距是指自动驾驶系统根据交通状况和车速的变化，动态调整车头间距。例如，在高速公路上，车辆之间的车头间距可以相对较大，而在城市道路上，车辆之间的车头间距可能较小。</p><p>选择何种Headway类型取决于自动驾驶系统的设计和车辆的使用场景。固定间距可以提供稳定的跟随效果，而可变间距可以根据实际情况进行灵活调整。</p><h6 id="IC"><a href="#IC" class="headerlink" title="IC"></a>IC</h6><p> Inter Change 英文缩写，意为高速公路转换出入口，即高速公路至一般公路的出入匝道。从标有“IC”的地方，可以下高速公路。</p><h6 id="JC"><a href="#JC" class="headerlink" title="JC"></a><strong>JC</strong></h6><p> Joint Change&#x2F;Circuit 的英文缩写，意为高速公路连接口或连接匝道。即不同高速公路之间的连接线路。从标有“JC”可以直接转到另一条高速公路上。</p><h6 id="SA"><a href="#SA" class="headerlink" title="SA :"></a><strong>SA</strong> :</h6><p>Service Area 的英文缩写，意为服务区。特指高速公路服务区。</p><h6 id="PA"><a href="#PA" class="headerlink" title="PA"></a><strong>PA</strong></h6><p> Parking Area 的英文缩写，意为停车区域。特指高速公路停车区。</p><h6 id="TG"><a href="#TG" class="headerlink" title="TG"></a><strong>TG</strong></h6><p> Toll Gate 的英文缩写，意为收费站。遇到这个标志，您要掏腰包了。</p><h6 id="IN"><a href="#IN" class="headerlink" title="IN"></a><strong>IN</strong></h6><p>路径入口。一般是指环岛的入口，或从辅路进到主路的地方。</p><h6 id="OUT"><a href="#OUT" class="headerlink" title="OUT"></a><strong>OUT</strong></h6><p> 路径出口。一般是指环岛的出口，或从主路转到辅路的的地方。</p><h6 id="Motorway"><a href="#Motorway" class="headerlink" title="Motorway"></a><strong>Motorway</strong></h6><p>高速公路</p><h6 id="UrbanMotorway"><a href="#UrbanMotorway" class="headerlink" title="UrbanMotorway"></a><strong>UrbanMotorway</strong></h6><p>城市快速路</p><h6 id="LocalRoad"><a href="#LocalRoad" class="headerlink" title="LocalRoad"></a><strong>LocalRoad</strong></h6><p>一般道路</p><h6 id="道路参考线-："><a href="#道路参考线-：" class="headerlink" title="**道路参考线 **："></a>**道路参考线 **：</h6><p>表示两个相邻道路节点间的道路几何形态。道路参考线可以理解为道路中心线在水平面的投影，也就是说道路参考线反映的是道路俯视的形状，而不包括坡度、起伏等特征。</p><h6 id="TSR-（Traffic-Sign-Recognition）"><a href="#TSR-（Traffic-Sign-Recognition）" class="headerlink" title="TSR （Traffic Sign Recognition）"></a><strong>TSR （Traffic Sign Recognition）</strong></h6><p>交通标志识别，自动驾驶系统中的一个重要功能。它通过使用摄像头或其他传感器来识别道路上的交通标志，从而帮助车辆识别和理解道路上的交通规则和限制。TSR 可以识别各种类型的交通标志，例如限速标志、禁止停车标志、道路优先标志等，并将这些信息传递给自动驾驶系统，以帮助车辆做出相应的决策和行驶策略。</p><h6 id="SOC（system-on-chip）"><a href="#SOC（system-on-chip）" class="headerlink" title="SOC（system on chip）"></a><strong>SOC（system on chip）</strong></h6><p>系统级芯片，将核心模块都放在一个芯片上（GPU\CPU\ISP\DSP）</p><h6 id="BSW-Blind-Spot-Warning"><a href="#BSW-Blind-Spot-Warning" class="headerlink" title="BSW(Blind Spot  Warning)"></a>BSW(Blind Spot  Warning)</h6><p>盲点警告系统， aux 指的是辅助或额外功能或系统。在自动驾驶上下文中，可能指的时为自动驾驶功能提供辅助或增强功能的系统&#x2F;</p><h6 id="SWC-steering-wheel-controls"><a href="#SWC-steering-wheel-controls" class="headerlink" title="SWC(steering wheel controls)"></a>SWC(steering wheel controls)</h6><p>方向盘控制</p><h6 id="GPS-RTK"><a href="#GPS-RTK" class="headerlink" title="GPS RTK"></a>GPS RTK</h6><p>RTK是一种实时动态载波相位差分技术，它实时处理两个测量站载波相位观测量的差分，将基准站采集的载波相位发给用户接收机，进行求差解算坐标。这是一种高精度、实时、连续的GPS定位技术，能够消除GPS定位误差造成的影响，实现对移动接收机的实时、连续、高精度定位。<strong>更精确的坐标</strong>。</p><h6 id="ODD（Operational-Design-Domain）"><a href="#ODD（Operational-Design-Domain）" class="headerlink" title="ODD（Operational Design Domain）"></a>ODD（Operational Design Domain）</h6><p>指自动驾驶汽车可以安全可靠地行驶的特定环境、条件和时段范围。它是自动驾驶技术的实现和应用的基础之一，对于保证自动驾驶车辆的安全性和可靠性至关重要.</p><h6 id="NOP（Navigate-on-Pilot）"><a href="#NOP（Navigate-on-Pilot）" class="headerlink" title="NOP（Navigate on Pilot）"></a>NOP（Navigate on Pilot）</h6><p>一种辅助驾驶功能，它允许车辆在特定条件下按照高精地图导航规划的路径自动巡航行驶。NOP功能是基于L2级辅助驾驶，并融合了导航系统、高精地图以及性能更强的辅助驾驶软硬件，以实现<strong>自动变道、自动上下匝道、自动超车</strong>等多种高阶辅助驾驶功能。然而，虽然NOP提供了这些高级功能，但它仍然属于辅助驾驶的范畴，并未达到L3级有条件的自动驾驶。</p><p>当NOP功能开启时，系统会根据此前的导航信息自动识别可支持的高精地图路段，并自动执行如打转向灯及变道等操作，以超越前方慢车或切换当前道路。如果车辆离开了高精地图区域，系统会主动告知驾驶者并及时退出NOP模式。</p><p>NOP的功能和特性与行业内统称的NOA（Navigate On Autopilot，<strong>自动领航辅助驾驶</strong>）相似。不同的汽车制造商可能会为自己的辅助驾驶系统命名不同的名称，以体现其特色和差异化，但它们在本质上是相似的。</p><p>值得注意的是，尽管NOP提供了许多便利的自动驾驶功能，但它仍然需要驾驶者的监督和参与。驾驶者应当随时准备接管车辆的控制权，以确保行驶的安全。因此，在自动驾驶领域，NOP被归类为辅助驾驶功能，而不是完全的自动驾驶系统。</p><h5 id="ADAS"><a href="#ADAS" class="headerlink" title="ADAS"></a>ADAS</h5><p>Advanced Driver Assistance system(ADAS)高级驾驶辅助系统</p><p>核心：环境感知</p>]]></content>
    
    
    
    <tags>
      
      <tag>Gis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>坐标以及tile mesh 的转换</title>
    <link href="/2024/11/05/%E5%9D%90%E6%A0%87%E5%8F%8ATileMesh%E8%BD%AC%E6%8D%A2/"/>
    <url>/2024/11/05/%E5%9D%90%E6%A0%87%E5%8F%8ATileMesh%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="坐标及Tile-Mesh转换"><a href="#坐标及Tile-Mesh转换" class="headerlink" title="坐标及Tile|Mesh转换"></a>坐标及Tile|Mesh转换</h2><h3 id="1-不同的坐标系"><a href="#1-不同的坐标系" class="headerlink" title="1.不同的坐标系"></a>1.不同的坐标系</h3><h4 id="1-1-WGS84坐标"><a href="#1-1-WGS84坐标" class="headerlink" title="1.1 WGS84坐标"></a>1.1 WGS84坐标</h4><p>​地球坐标系：GPS&#x2F;谷歌地图卫星（客户需要的坐标）</p><h4 id="1-2-GCJ02坐标"><a href="#1-2-GCJ02坐标" class="headerlink" title="1.2 GCJ02坐标"></a>1.2 GCJ02坐标</h4><p>​火星坐标系：中国国家测绘局定制的地理信息系统的坐标系统，在中国使用的地图产品必须是加密后的坐标，GCJ02为WGS84坐标加密后；主要产品：高德地图、腾讯地图、阿里云地图、谷歌国内地图</p><h4 id="1-3-BD09坐标"><a href="#1-3-BD09坐标" class="headerlink" title="1.3 BD09坐标"></a>1.3 BD09坐标</h4><p>​百度坐标系。在GCJ02的基础上进行了二次加密</p><h4 id="1-4-NDS坐标"><a href="#1-4-NDS坐标" class="headerlink" title="1.4 NDS坐标"></a>1.4 NDS坐标</h4><p>将经度映射到<br>$$<br>[-2^{31},2^{31})<br>$$<br>将纬度映射到<br>$$<br>[-2^{30},2^{30})<br>$$<br><img src="/images/image-20241106152704048.png" alt="image-20241106152704048"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//02坐标系向nds坐标系转换</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Cnv02Coord2NdsCoord</span><span class="hljs-params">(<span class="hljs-type">double</span> d)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> d * <span class="hljs-number">2147483648.0</span> / <span class="hljs-number">180.0</span>;<br>    <span class="hljs-keyword">return</span> d* (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">30</span>)/<span class="hljs-number">90</span><br>&#125;<br><br><span class="hljs-comment">// NDS坐标系向02坐标系转换</span><br><span class="hljs-type">double</span> <span class="hljs-built_in">CnvNdsCoordTo02Coord</span>(<span class="hljs-type">int</span> iCoord)<br>&#123;<br><span class="hljs-built_in">return</span> ((<span class="hljs-type">double</span>)iCoord) * <span class="hljs-number">180.0</span> / <span class="hljs-number">2147483648.0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Morton Codes</p><p>通过int32 表示经纬度：<br>$$<br>x&#x3D;x_{31}x_{30}…x_{1}x_{0}<br>$$</p><p>$$<br>y&#x3D;y_{30}y_{29}…y_{1}y_{0}<br>$$</p><p>morton code通过63-bit表示<br>$$<br>c&#x3D;x_{31} y_{30} x_{30}… x_{1}y_{0}x_{0}<br>$$</p><p>$$<br>0 \leq c&lt;2^{63}<br>$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">CoordToMortonCode</span><span class="hljs-params">(<span class="hljs-type">int</span> iLong, <span class="hljs-type">int</span> iLat, uint64&amp; uiMortonCode)</span></span><br><span class="hljs-function"></span>&#123;<br>uiMortonCode = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++)<br>&#123;<br>uint64 uiTmp64 = <span class="hljs-number">0</span>;<br>uiTmp64 = (iLong &gt;&gt; i) &amp; <span class="hljs-number">0x1</span>;<br>uiTmp64 |= ((iLat &gt;&gt; i) &amp; <span class="hljs-number">0x1</span>) &lt;&lt; <span class="hljs-number">1</span>;<br><br>uiMortonCode |= (uiTmp64 &lt;&lt; <span class="hljs-number">2</span> * i);<br>&#125;<br><span class="hljs-keyword">return</span> SUCCESS;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MortonCodeToCoord</span><span class="hljs-params">(uint64 uiMortonCode, <span class="hljs-type">int</span>&amp; iLong, <span class="hljs-type">int</span>&amp; iLat)</span></span><br><span class="hljs-function"></span>&#123;<br>iLong = <span class="hljs-number">0</span>;<br>iLat = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++)<br>&#123;<br>uint uiTmpCode = uiMortonCode &amp; <span class="hljs-number">0x3</span>;<br><br>iLong |= ((uiTmpCode &amp; <span class="hljs-number">0x1</span>) &lt;&lt; i);<br>iLat |= (((uiTmpCode &amp; <span class="hljs-number">0x2</span>) &gt;&gt; <span class="hljs-number">1</span>) &lt;&lt; i);<br><br>uiMortonCode &gt;&gt;= <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">return</span> SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Coord shift</strong></p><p><img src="/images/image-20231229150230040.png" alt="image-20231229150230040"></p><p><strong>NDS中road 形状点存储</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">bit</span>:<span class="hljs-number">2</span> ShapePointType<br>&#123; <br>BASE_LINK_NO_GEOMETRY= <span class="hljs-number">0</span>,<br>BASE_LINK_WITH_GEOMETRY= <span class="hljs-number">1</span>,<br>ROUTE_LINK= <span class="hljs-number">2</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>BASE_LINK_NO_GEOMETRY：没有形状点</p><p>BASE_LINK_WITH_GEOMETRY<br>Link的 start 和end 都在当前tile 内。形状点存储的是相对于start 的offset。start ：相对于Tile中心点的offset</p><p>ROUTE_LINK<br>形状点存储在roadGeoLine: V0存储相对于Tile中心点的offset。</p><h3 id="2-Mesh-Tile"><a href="#2-Mesh-Tile" class="headerlink" title="2.Mesh &amp;Tile"></a>2.Mesh &amp;Tile</h3><h4 id="2-1-MeshID"><a href="#2-1-MeshID" class="headerlink" title="2.1 MeshID"></a>2.1 MeshID</h4><p>GCJ02-&gt;nds坐标</p><p>根据nds坐标获取 level 13 和level 9的tileID 以及MeshID</p><h3 id="3-坐标转换方法"><a href="#3-坐标转换方法" class="headerlink" title="3.坐标转换方法"></a>3.坐标转换方法</h3><p>参照MeshListTool中的坐标转换方法</p><h3 id="4-Tile转换方法"><a href="#4-Tile转换方法" class="headerlink" title="4.Tile转换方法"></a>4.Tile转换方法</h3><h4 id="4-1-NDS-Tiling-Scheme-网格划分"><a href="#4-1-NDS-Tiling-Scheme-网格划分" class="headerlink" title="4.1 NDS-Tiling Scheme(网格划分)"></a>4.1 NDS-Tiling Scheme(网格划分)</h4><p>NDS中，数据是以 <strong>tile</strong> 为单位进行存储。一个tile包含在这个tile边界的地理范围的所有Feature; 这些Feature按照datascript定义的格式进行编码：<strong>BLOBS</strong></p><p><strong>Tiles and Building Blocks</strong></p><p>导航数据在存储的时候，按照存储方式不同，分为BLOBS（二进制流）和relational(关系表)</p><p>每个Feature都有唯一的坐标点，可以通过地理位置来查找坐标点</p><p><strong>Tiles 的优点：</strong></p><p>​通过一次访问数据库，可以把同一地理范围内的所有相关数据都加载进来，提高地图显示和路径规划的性能；</p><p>​tiles作为数据更新的单位，只需要对每一个tile记录一个版本信息，节省大量的数据空间</p><p>​tile实现对feature的分层引用，</p><p>​tiling scheme 应用<strong>BLOB</strong>方式存储， BMD、 routing、lane等,按照tile方式分隔数据，按tile划分数据后，通过一个快速查找周围的数据；</p><p><strong>Tile and level</strong></p><p>level的概念：在一个level上对应的所有tile刚好覆盖了整个地球表面，在同一个level的每个tile的边界宽度都是在固定的经纬度宽，同一level的tile在wgs84坐标系统中大小是一致的。</p><p><strong>Level划分</strong>：不同比例尺下，可以看到不同颗粒度的地图信息</p><p><strong>地图块</strong>：将整个地图换分为众多小格子，便于地图数据的更新维护</p><p><strong>最高level（level 0）</strong> 只包含<strong>2个tiles</strong>,到下一级leve时，每个当前level的tile分割成下一级level的 4个大小一样的tiles,</p><p><strong>最低level (level 15)</strong></p><p>NDS使用<strong>level</strong> <strong>13</strong> 定义最详细的路网数据，在routing data中没有比level13更低的数据</p><p>对于低于level13的level是留给map display使用了，比如存储详细的city map在level 14中</p><p>NDS使用中心点作为其tile的anchor point。tile中的点坐标在存储的时候，只是存储相对于anchor point的offset。在存储link的shapepoint时候，第一个点为相对anchor point的offset，其后的点就是相对前一个点的offset。</p><p>（route link虽然也是横跨多个tile，但是route link不会被切分，route link从属于其start node所在的tile。route link是一个逻辑feature，本身没有geometry信息，其geometry信息被提取出来单独做成另一个feature：geo line，所以route link对应的geo line将会被切分。具体细节以后讨论。）</p><p>feature被切分后，原来feature所对应的关联信息（比如name object）会都保留到切分后的feature上</p><h4 id="5-坐标计算相关"><a href="#5-坐标计算相关" class="headerlink" title="5. 坐标计算相关"></a>5. 坐标计算相关</h4><h6 id="1-一个线段，给定旋转角度，计算旋转后的点坐标"><a href="#1-一个线段，给定旋转角度，计算旋转后的点坐标" class="headerlink" title="1. 一个线段，给定旋转角度，计算旋转后的点坐标"></a>1. 一个线段，给定旋转角度，计算旋转后的点坐标</h6><p>理解：</p><p>在直角坐标中，有p(x, y)，直线op长度为r，直线op和x轴正向夹角为a。直线op围绕原点做逆时针方向b度的旋转，到达p’ (s,t)，如下图。</p><p><img src="/images/20200302210437662.png" alt="img"></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tex">s = r cos(a + b) = r cos(a)cos(b) – r sin(a)sin(b)   (1.1)<br>t = r sin(a + b) = r sin(a)cos(b) + r cos(a)sin(b)   (1.2)<br> <br>其中 x = r cos(a) , y = r sin(a)<br>代入(1.1), (1.2) ,<br> <br>s = x cos(b) – y sin(b)    (1.3)<br>t = x sin(b) + y cos(b)    (1.4)<br></code></pre></td></tr></table></figure><p>代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RotationTransform</span><span class="hljs-params">(<span class="hljs-type">const</span> Coord &amp;clOriP, <span class="hljs-type">const</span> Coord &amp;clRotatedP, <span class="hljs-type">const</span> <span class="hljs-type">double</span> angle, Coord &amp;clPoint)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">double</span> dRadian = angle * PI / <span class="hljs-number">180.0f</span>;<br><br>clPoint.X = clOriP.X + (clRotatedP.X - clOriP.X) * <span class="hljs-built_in">cos</span>(dRadian) - (clRotatedP.Y - clOriP.Y) * <span class="hljs-built_in">sin</span>(dRadian);<br>clPoint.Y = clOriP.Y + (clRotatedP.X - clOriP.X) * <span class="hljs-built_in">sin</span>(dRadian) + (clRotatedP.Y - clOriP.Y) * <span class="hljs-built_in">cos</span>(dRadian);<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="2-判断线段的位置"><a href="#2-判断线段的位置" class="headerlink" title="2. 判断线段的位置"></a>2. 判断线段的位置</h6><p>判断两根Link的相对位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TurnDirection <span class="hljs-title">DetermineTurnDirection</span><span class="hljs-params">(<span class="hljs-type">const</span> &amp;nextLink, <span class="hljs-type">const</span> &amp;otherLink,<span class="hljs-type">bool</span> IsMerge)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (nextLink.link_index == <span class="hljs-number">313</span> &amp;&amp; nextLink.tile_id == <span class="hljs-number">557546882</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">//查找交点</span><br>    nav::geo::Wgs84 p0;<br>    nav::geo::Wgs84 p1;<br>    nav::geo::Wgs84 p2;<br><br>    <span class="hljs-keyword">if</span> (IsMerge) &#123;<br>        p0 = nextLink.clEndPoint;<br>        p1 = nextLink.clstartPoint;<br>        p2 = otherLink.clstartPoint;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        p0 = nextLink.clstartPoint;<br>        p1 = nextLink.clEndPoint;<br>        p2 = otherLink.clEndPoint;<br>    &#125;<br><br>    <span class="hljs-type">double</span> ax = p<span class="hljs-number">1.</span><span class="hljs-built_in">getLongitude</span>()- p<span class="hljs-number">0.</span><span class="hljs-built_in">getLongitude</span>();<br>    <span class="hljs-type">double</span> ay = p<span class="hljs-number">1.</span><span class="hljs-built_in">getLatitude</span>() - p<span class="hljs-number">0.</span><span class="hljs-built_in">getLatitude</span>();<br>    <span class="hljs-type">double</span> bx = p<span class="hljs-number">2.</span><span class="hljs-built_in">getLongitude</span>() - p<span class="hljs-number">0.</span><span class="hljs-built_in">getLongitude</span>();<br>    <span class="hljs-type">double</span> by = p<span class="hljs-number">2.</span><span class="hljs-built_in">getLatitude</span>() - p<span class="hljs-number">0.</span><span class="hljs-built_in">getLatitude</span>();<br>    <span class="hljs-comment">//向量(ax,ay,0)叉乘向量(bx,by,0)得到的向量为(0,0,ab),由ab的正负和观察方向界定左右</span><br>    <span class="hljs-type">double</span> ab = (ax*by - ay * bx);<br>    <span class="hljs-keyword">if</span> (ab - <span class="hljs-number">0.00000000</span> &gt; <span class="hljs-number">0.00000000</span>) &#123;<br>        <span class="hljs-keyword">return</span> IsMerge ? TurnDirection::LEFT: TurnDirection::RIGHT;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> IsMerge?TurnDirection::RIGHT: TurnDirection::LEFT;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Gis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据格式</title>
    <link href="/2024/11/05/%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F/"/>
    <url>/2024/11/05/%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h4 id="地理空间数据"><a href="#地理空间数据" class="headerlink" title="地理空间数据"></a>地理空间数据</h4><p>基于文件的空间数据，Gis直接支持的空间数据类型主要包括矢量数据文件、3D模型、映像文件等。</p><ul><li>矢量数据文件：shp、sdc、file Gdb、CAD、GeoJson、xml等</li><li>3D模型：3DMax、SKP等</li><li>影像文件（栅格文件）：TIF、TIFF、JPEG、GIF</li></ul><h5 id="1-GeoJson"><a href="#1-GeoJson" class="headerlink" title="1. GeoJson"></a>1. GeoJson</h5><p>GeoJson是Json数据（键值对）针对地理数据的变种。</p><p>用于数据的显示</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    “type”<span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Feature&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;geometry&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-string">&quot;type&quot;</span>：“Point”<span class="hljs-punctuation">,</span><br>        “coordinates”<span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><span class="hljs-number">125.6</span><span class="hljs-punctuation">,</span><span class="hljs-number">10.1</span><span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-string">&quot;name&quot;</span>：<span class="hljs-string">&quot;liaoning&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>最外层</strong></p><ul><li><p>type: Featrue 表示特征要素，FeatureCollection表示特征要素的集合</p></li><li><p>geomotry:存储特征要素的实际形状描述</p></li><li><p>properties：存储要素的属性</p><p>Geometry:</p><ul><li>type：存储要素的类型：Point、LineString、Polygon、MultiPoint、MultiLineString、MultiPolygon</li><li>coordinates:坐标</li></ul></li></ul><p>在FeatureCollection中，features:可以存放多个feature,并且feature的种类可以不同。</p><p>GeoJson可能有一个可选的 <strong>crs</strong> 成员，其值必须是一个坐标参考系统的对象。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-string">&quot;type&quot;</span>：<span class="hljs-string">&quot;FeatureCollection&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;crs&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;name&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;urn:ogc:def:crs:OGC:1.3:CRS84&quot;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>”feature“：<span class="hljs-punctuation">[</span><br>    <span class="hljs-comment">//其他内容</span><br><span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">clFeature.mProperties.<span class="hljs-built_in">addProperty</span>(<span class="hljs-string">&quot;HAS_TRAFFIC_LIGHT&quot;</span>, <span class="hljs-built_in">to_string</span>(m_bhas_traffic_light).<span class="hljs-built_in">data</span>());<br>clFeature.mGeom.<span class="hljs-built_in">setGeometry_Point</span>(<span class="hljs-built_in">make_tuple</span>(clDot.m_clDotPos.dx, clDot.m_clDotPos.dy, <span class="hljs-number">0</span>));<br><span class="hljs-comment">//写入到文件</span><br>m_clLaneBoundaryStartPointWriter.<span class="hljs-built_in">addFeature</span>(clFeature)<br>        <br></code></pre></td></tr></table></figure><h5 id="2-ArcGis格式解析"><a href="#2-ArcGis格式解析" class="headerlink" title="2. ArcGis格式解析"></a>2. ArcGis格式解析</h5><h6 id="shape数据"><a href="#shape数据" class="headerlink" title="shape数据"></a>shape数据</h6><p>shapefile是Arcview Gis3.x的原生数据，属于简单要素类，用点、线、多边形存储要素的形状、不存储拓扑关系，简单、快速显示的优点。一个shapefile是由若干个文件组成的，<strong>空间信息</strong>、C:\nic_make\nic\input\SD\Incar\liaoning\road信息分离存储</p><h6 id="shp文件-图形格式"><a href="#shp文件-图形格式" class="headerlink" title=".shp文件(图形格式)"></a>.shp文件(图形格式)</h6><p>保存元素的几个实体，存储的是几个要素的空间信息，XY坐标：一般X对应经度，Y对应纬度</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs tex">header: 100个字节<br>CurDA:对应的偏移量/大小<br>FileCode:文件编号<br>Unused1:<br>Unused2:<br>Unused3:<br>Unused4:<br>Unused5:未被使用的32位整数<br>FileLength：文件长度，包括文件头<br>Version：b版本信息<br>Type：图形类型<br>Xmin：<br>Ymin：<br>Xmax：<br>Ymax:最小外接矩阵<br>Zmin：<br>Zmax:z的坐标值<br>Mmin:<br>Mmax：M坐标：测量值 不归属坐标系<br><br></code></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tex">图形类型：<br>Point:点<br>Ployline：折线<br>ploygon：多边形<br><br></code></pre></td></tr></table></figure><h6 id="shx文件-图形索引格式"><a href="#shx文件-图形索引格式" class="headerlink" title=".shx文件(图形索引格式)"></a>.shx文件(图形索引格式)</h6><p>几何体的位置索引，记录每一个几何体在shp文件之中的位置，加快向前向后搜索的效率。存储的是有关***.shp<em>*存储的索引信息，记录了在 *.shp中，空间数据是如何存储的，XY坐标的输入点在哪里，有多少XY坐标对等信息**；加快向前或向后搜索一个几何体的效率</em>*；文件索引</p><h6 id="dbf文件-属性数据格式"><a href="#dbf文件-属性数据格式" class="headerlink" title=".dbf文件(属性数据格式)"></a>.dbf文件(属性数据格式)</h6><p>存储地理数据的属性信息的dbase表，存储每个几何形状的属性数据</p><h6 id="prj文件"><a href="#prj文件" class="headerlink" title=".prj文件"></a>.prj文件</h6><p>定义的坐标系统：wGS84坐标</p><p>- </p><h5 id="3-WKT"><a href="#3-WKT" class="headerlink" title="3. WKT"></a>3. WKT</h5><p>OpenGIS定义地理参照坐标系的方式。</p><p>用于表示矢量几个对象，空间参照系统及空间参照系统之间的转换。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">&quot;POINT(<span class="hljs-number">109.027529</span> <span class="hljs-number">24.146990</span>)&quot; <br></code></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">&quot;POLYGON((<span class="hljs-number">117.062856</span> <span class="hljs-number">31.830043</span>, <span class="hljs-number">117.062856</span> <span class="hljs-number">31.830047</span>, <span class="hljs-number">117.063385</span> <span class="hljs-number">31.830047</span>, <span class="hljs-number">117.063385</span> <span class="hljs-number">31.830043</span>, <span class="hljs-number">117.062856</span> <span class="hljs-number">31.830043</span>))&quot;<br></code></pre></td></tr></table></figure><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">&quot;LINESTRING (30 10,<span class="hljs-number"> 10 </span>30,<span class="hljs-number"> 40 </span>40)&quot;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Gis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vector扩容</title>
    <link href="/2024/11/03/vector%E6%89%A9%E5%AE%B9/"/>
    <url>/2024/11/03/vector%E6%89%A9%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<p>vector 的扩容机制是动态数组管理内存和存储空间的重要策略。</p><ol><li><p>扩容触发条件<br>当向vector 插入新元素时，如果当前容量不足以容纳新元素，就会触发扩容机制。<br>当前元素末尾指针等于 end_of_storage （容量的末尾指针），就需要进行扩容。</p></li><li><p>扩容方式<br>2倍：显著减少内存分配的次数，提升性能，并减少内存碎片。<br>1.5倍：在节省空间的同时，可能会增加扩容的频率。</p></li><li><p>扩容过程</p><ul><li>申请新内存：根据扩容策略，申请一块更大的内存空间；</li><li>数据拷贝：将原内存中的数据拷贝到新申请的内存空间中；</li><li>释放原内存：将内存空间释放，以避免内存泄露。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>cpp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯</title>
    <link href="/2024/10/22/%E5%9B%9E%E6%BA%AF/"/>
    <url>/2024/10/22/%E5%9B%9E%E6%BA%AF/</url>
    
    <content type="html"><![CDATA[<h5 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h5>]]></content>
    
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>static</title>
    <link href="/2024/10/08/static/"/>
    <url>/2024/10/08/static/</url>
    
    <content type="html"><![CDATA[<p>在c++中，<code>static</code> 是一个非常重要的修饰符，可以应用于变量、函数、成员函数和成员变量。</p><h5 id="1-静态局部变量"><a href="#1-静态局部变量" class="headerlink" title="1.静态局部变量"></a>1.静态局部变量</h5><p>作用域函数内部的局部变量时，该变量的生命周期被延长到<strong>整个程序的生命周期</strong>， 但其作用域仍然限制到定义其的函数内部。<br>即使函数执行完毕，该变量的值也会保留到下次该函数被调用时。这种特性能够使得函数能够‘记住’之前的状态。</p><p>static 修饰的局部变量的存储位置在程序执行执行期间保持不变，且只在程序执行到该变量的声明时初始化一次。<br>即使函数被多次调用，static 局部变量也旨在第一次调用时初始化，之后的调用不会再初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> itime = <span class="hljs-number">1</span>;<br>itime++;<br>std::cout &lt;&lt; itime &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123;<br><span class="hljs-built_in">fun</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">2<br>3<br>4<br>5<br>6<br></code></pre></td></tr></table></figure><h5 id="2-修饰全局变量或函数"><a href="#2-修饰全局变量或函数" class="headerlink" title="2. 修饰全局变量或函数"></a>2. 修饰全局变量或函数</h5><p>主要作用：限制变量和函数的作用域，只能在定义它们的文件内部访问。由于避免在不同文件之间的命名冲突。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// file1.cpp</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> count = <span class="hljs-number">10</span>; <span class="hljs-comment">// count变量只能在file1.cpp中访问</span><br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// func函数只能在file1.cpp中访问</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Function in file1&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">// file2.cpp</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> count; <span class="hljs-comment">// 这里会导致编译错误，因为count是static的，不能在file2.cpp中访问</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">anotherFunc</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">func</span>(); <span class="hljs-comment">// 这里也会导致编译错误，因为func是static的，不能在file2.cpp中访问</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="3-修饰类的成员函数或变量"><a href="#3-修饰类的成员函数或变量" class="headerlink" title="3. 修饰类的成员函数或变量"></a>3. 修饰类的成员函数或变量</h5><p>在类的内部，<code>static</code> 成员变量或者函数属于成员本身，而不是类的特定对象。即所有对象共享一个static成员变量，无需每个对象都存储一份拷贝。<code>static</code> 成员函数能够在没有类的示例时访问。<br><code>static</code> 成员函数只能访问 <code>static</code>成员变量或者 静态成员函数。</p><p><code>static</code>成员变量在类外进行初始初始化，且 不需要加 <code>static</code>关键字。</p><p>单例模式使用了 <code>static</code> 关键字的特性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp; instance) = <span class="hljs-keyword">delete</span>;<br>Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp; instance) = <span class="hljs-keyword">delete</span>;<br><span class="hljs-function"><span class="hljs-type">static</span> Singleton* <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (_instance == <span class="hljs-literal">nullptr</span>) &#123;<br>_instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();<br>&#125;<br><span class="hljs-keyword">return</span> _instance;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Out</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">Singleton</span>() &#123;&#125;<br>~<span class="hljs-built_in">Singleton</span>() = <span class="hljs-keyword">default</span>;<br><br><span class="hljs-type">static</span> Singleton* _instance;<br>&#125;;<br><br>Singleton* Singleton::_instance = <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Singleton::<span class="hljs-built_in">GetInstance</span>()-&gt;<span class="hljs-built_in">Out</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-使用场景"><a href="#4-使用场景" class="headerlink" title="4. 使用场景"></a>4. 使用场景</h5><ul><li>static 局部变量：在函数的多次调用之间记住某个变量的值时；</li><li>static 全局变量或函数：显示变量或者函数的作用域，防止在其他文件中被访问；</li><li>static 类的成员变量或者函数：所有对象共享某个变量或者成员时；或者没有类的实例的情况下访问某个函数时。</li></ul>]]></content>
    
    
    <categories>
      
      <category>cpp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例模式</title>
    <link href="/2024/10/08/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2024/10/08/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>C++中 单例模式（singleton pattern）是一种设计模式，确保一个类只有一个实例，并提供一个全局访问点来获取该实例。</p><h4 id="线程安全的单例示例"><a href="#线程安全的单例示例" class="headerlink" title="线程安全的单例示例"></a>线程安全的单例示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">const</span> Test&amp; t) = <span class="hljs-keyword">delete</span>;<br>    Test&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Test&amp; t) = <span class="hljs-keyword">delete</span>;<br><br><br>    <span class="hljs-function"><span class="hljs-type">static</span> Test* <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_mutex)</span></span>;<br>        <span class="hljs-keyword">if</span> (_instance == <span class="hljs-literal">nullptr</span>) &#123;<br>            _instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Test</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> _instance;<br>    &#125;<br>    <span class="hljs-comment">//更简单的方式</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> Test &amp; <span class="hljs-title">GetInstance1</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">static</span> Test instancetest;<span class="hljs-comment">//在第一次调用时进行初始化(局部静态变量初始化延迟)</span><br>        <span class="hljs-keyword">return</span> instancetest;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Out</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;test&quot;</span> &lt;&lt; std::endl; &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Test</span>() &#123;&#125;<br>    ~<span class="hljs-built_in">Test</span>() = <span class="hljs-keyword">default</span>;<br><br>    <span class="hljs-type">static</span> Test* _instance;<br>    <span class="hljs-type">static</span> std::mutex _mutex;<span class="hljs-comment">//在静态成员函数中只能访问静态成员变量</span><br><br>&#125;;<br><span class="hljs-comment">//初始化</span><br>Test * Test::_instance = <span class="hljs-literal">nullptr</span>;<br>std::mutex Test::_mutex;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    Test::<span class="hljs-built_in">GetInstance</span>()-&gt;<span class="hljs-built_in">Out</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p><code>static</code> 关键字</p><ul><li>修改成员变量时，所有对象值维持一份拷贝，可以实现不同对象间的数据共享；不需要实例化对象即可访问；不能在类的内部初始化，一般在类外部初始化，并且初始化时不加 <code>static</code>;</li><li>修饰成员函数时：该函数不接受 <code>this</code> 指针，<strong>只能访问类的静态成员</strong>；不需要实例化对象即可访问。</li></ul><p>当<code>static</code> 关键字作用于类的成员函数或成员变量时，<strong>这些成员属于类本身</strong>，而不是类的某个特定对象。意味着，静态成员可以在没有创建类对象的情况下被访问的修改。<br>静态成员函数只能访问静态成员变量和静态成员函数，因为他们没有 <code>this</code>指针。静态成员函数通常用于实现那些与特定对象状态无关的功能。</p><p><code>static</code> 修饰局部变量时，其生命周期贯穿整个程序运行期间。</p>]]></content>
    
    
    <categories>
      
      <category>cpp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚函数</title>
    <link href="/2024/10/08/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    <url>/2024/10/08/%E8%99%9A%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="面向对象特征"><a href="#面向对象特征" class="headerlink" title="面向对象特征"></a>面向对象特征</h4><ul><li>封装：将客观事物封装成抽象的类，类可以把自己的数据和方法暴露给可信的类或者对象，对不可信的进行信息隐藏</li><li>继承：可以使用现有类的所有功能，无需重新编写原来的类即可对功能进行扩展</li><li>多态：一个类实例的相同方法在不同情形下有不同的表现形式，使不同内部结构的对象可以共享相同的外部接口。</li></ul><h4 id="多态的实现有哪几种"><a href="#多态的实现有哪几种" class="headerlink" title="多态的实现有哪几种"></a>多态的实现有哪几种</h4><ul><li>静态多态：通过重载和模板技术实现的，在编译期间确定</li><li>动态多态：通过虚函数和继承关系实现的，执行动态绑定，在运行期间确定</li></ul><h4 id="动态多态作用，有那些必要条件"><a href="#动态多态作用，有那些必要条件" class="headerlink" title="动态多态作用，有那些必要条件"></a>动态多态作用，有那些必要条件</h4><p>作用：</p><ul><li>隐藏实现细节，使代码模块化，提高代码的可复用性</li><li>接口重用，派生列的功能可以被基类的指针&#x2F;引用所调用，向后兼容，提高代码的维护性和可扩展性</li></ul><p>必要条件</p><ul><li>有继承</li><li>与虚函数覆盖</li><li>有基类指针&#x2F;引用指向子类对象</li></ul><h4 id="动态绑定如何实现"><a href="#动态绑定如何实现" class="headerlink" title="动态绑定如何实现"></a>动态绑定如何实现</h4><p>当编译器发现类中有虚函数时，会创建一个虚函数表，把虚函数的函数入口地址放在虚函数表中，并在对象中增加一个指针vptr ，用于指向类的虚函数表。当派生类覆盖基类的虚函数时，会将虚函数表中对应的指针替换，从而调用派生类中覆盖后的虚函数，实现动态绑定。</p><h4 id="纯虚继承作用，如何实现？"><a href="#纯虚继承作用，如何实现？" class="headerlink" title="纯虚继承作用，如何实现？"></a>纯虚继承作用，如何实现？</h4><p>为了实现一个接口，起到规范的作用，想要继承类就需要覆盖函数。</p><p>实现：在函数声明时结尾 <code>=0</code>。</p><h4 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h4><p>被 <code>virtual</code> 关键字修饰的成员函数</p><h4 id="为什么基类的构造函数不能定义为虚函数"><a href="#为什么基类的构造函数不能定义为虚函数" class="headerlink" title="为什么基类的构造函数不能定义为虚函数"></a>为什么基类的构造函数不能定义为虚函数</h4><p>虚函数的调用依赖于虚函数表，指向虚函数表的指针需要在构造函数中进行初始化，所以无法调用定义为虚函数的构造函数。</p><h4 id="什么基类的析构函数需要定义为虚函数"><a href="#什么基类的析构函数需要定义为虚函数" class="headerlink" title="什么基类的析构函数需要定义为虚函数"></a>什么基类的析构函数需要定义为虚函数</h4><p>为了实现动态绑定，基类指针指向派生类对象，如果析构函数不是虚函数，那么在对象销毁时，就是调用基类的析构函数，只能销毁派生类对象中的部分数据，所以必须将析构函数定义为虚函数。从而在对象销毁时，调用派生类的析构函数，从而销毁派生对象的所有数据。</p>]]></content>
    
    
    <categories>
      
      <category>cpp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>野指针与悬挂指针</title>
    <link href="/2024/10/06/%E9%87%8E%E6%8C%87%E9%92%88%E4%B8%8E%E6%82%AC%E6%8C%82%E6%8C%87%E9%92%88/"/>
    <url>/2024/10/06/%E9%87%8E%E6%8C%87%E9%92%88%E4%B8%8E%E6%82%AC%E6%8C%82%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h4 id="c-中野指针和悬挂指针的区别"><a href="#c-中野指针和悬挂指针的区别" class="headerlink" title="c++中野指针和悬挂指针的区别"></a>c++中野指针和悬挂指针的区别</h4><p>两者都可能导致程序产生不可预测的行为，但有明显的区别。</p><ol><li>野指针：一种未被初始化的指针，通常会指向一个随机的内存地址。这个地址不可控，使用可能会导致程序崩溃或者数据损坏。</li><li>悬挂指针：一个原本合法的指针，但指向的内存已被释放或重新分配。当访问此指针指向的内存时，会导致未定义行为，因为那块内存数据可能已经不是期望的数据了。</li><li>如何避免野指针</li></ol><ul><li>初始化指针：在声明一个指针时，立刻初始化</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> *ptr=<span class="hljs-literal">nullptr</span>;<br></code></pre></td></tr></table></figure><ul><li>使用智能指针：c++智能指针可以帮助自动管理指针的生命周期，减少手动管理的错误。</li></ul><ol start="4"><li>如何避免悬挂指针</li></ol><ul><li>在删除对象后，将指针设置为nullptr,确保指针不再指向已经释放的内存。</li><li>尽量使用智能指针，会自动处理指针的生命周期，减少悬挂指针的产生。</li></ul>]]></content>
    
    
    <categories>
      
      <category>cpp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>智能指针</title>
    <link href="/2024/10/06/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <url>/2024/10/06/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍智能指针的使用场景"><a href="#介绍智能指针的使用场景" class="headerlink" title="介绍智能指针的使用场景"></a>介绍智能指针的使用场景</h4><p>c++中的智能指针主要用于管理动态分配的内存，避免内存泄漏。<br>c++11标准引入了三种主要的智能指针： <code>std::unique_ptr</code>、<code>std::shared_ptr</code>、<code>std::weak_ptr</code>。</p><h5 id="1-std-unique-ptr"><a href="#1-std-unique-ptr" class="headerlink" title="1. std::unique_ptr"></a>1. std::unique_ptr</h5><p>独占所有权的智能指针，同一时间内只能有一个 <code>unique_ptr</code> 指向一个特定的对象，当<code>unique_ptr</code>被销毁时，它所指向的对象也会被销毁。</p><h6 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h6><p>需要确保一个对象只被一个指针所拥有时；<br>自动管理资源，如文件句柄或者互斥锁时。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>()&#123;&#125;<br>    ~<span class="hljs-built_in">Test</span>()&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::unique_ptr&lt;Test&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Test())</span></span>;<br>    ptr-&gt;<span class="hljs-built_in">test</span>();<br>    <span class="hljs-comment">//当ptr离开作用域时，指向的对象也会被销毁。</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//进阶</span><br>   <span class="hljs-keyword">class</span> <span class="hljs-title class_">L2MapSDKImpl</span><br>   &#123;<br>   <span class="hljs-keyword">public</span>:<br>      <span class="hljs-function"><span class="hljs-type">static</span> L2MapSDKImpl&amp; <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function">      </span>&#123;<br>         <span class="hljs-type">static</span> L2MapSDKImpl instance;<span class="hljs-comment">//类的静态局部变量</span><br>         <span class="hljs-keyword">return</span> instance;<br>      &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-std-shared-ptr"><a href="#2-std-shared-ptr" class="headerlink" title="2.std::shared_ptr"></a>2.std::shared_ptr</h5><p>共享所有权的智能指针，多个<code>shared_ptr</code> 可以指向同一个对象。其内部使用引用计数确保只有当最后一个指向对象的 <code>shared_ptr</code>被销毁时，对象才销毁。多个智能指针可以指向相同对象，对象和相关资源会在 最后一个引用被销毁时释放。可以通过成员函数<code>use_count()</code> 查看资源的所有者个数。</p><p>内存释放条件：当计数器的值变为0时，表示没有任何 shared_ptr 对象与该计数器关联，即没有任何对象使用该内存资源。此时，会自动释放内存，并调用管理对象的析构函数。</p><h6 id="shared-ptr-是如何实现的"><a href="#shared-ptr-是如何实现的" class="headerlink" title="shared_ptr 是如何实现的"></a>shared_ptr 是如何实现的</h6><ol><li>构造函数中计数初始化为1</li><li>拷贝构造函数中计数值+1</li><li>赋值运算符中，左边的对象引用计数-1，右边的对象引用计数+1</li><li>析构函数中引用计数-1</li><li>在赋值运算符和析构函数中，如果-1 后为0，则调用delete 释放对象。</li></ol><h6 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h6><p>多个所有者之间共享对象时；<br>需要通过复制构造函数或者赋值操作符来复制智能指针时；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::shared_ptr&lt;Test&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Test())</span></span>;<br>    std::shared_ptr&lt;Test&gt; ptr2=ptr1;<br>    ptr1-&gt;<span class="hljs-built_in">test</span>();<br>    <span class="hljs-comment">//当ptr1和ptr2离开作用域时，他们指向的对象会被销毁</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-std-weak-ptr"><a href="#3-std-weak-ptr" class="headerlink" title="3. std::weak_ptr"></a>3. std::weak_ptr</h5><p>不拥有对象所有权的智能指针，指向一个由std::shared_ptr管理的对象，用于解决shared_ptr之间循环引用的问题。</p><h6 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h6><p>需要访问但不拥有有shared_ptr管理的对象时；<br>解决shared_ptr 的循环引用问题时；<br>weak_ptr 和shared_ptr 需要搭配使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::shared_ptr&lt;Test&gt; <span class="hljs-title">sharedPtr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Test())</span></span>;<br>    std::weak_ptr&lt;Test&gt; weakptr=sharedPtr;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">auto</span> lockedsharedptr= weakptr.<span class="hljs-built_in">lock</span>())&#123;<br>        lockedsharedptr-&gt;<span class="hljs-built_in">test</span>();<br>    &#125;<br>    <span class="hljs-comment">//shared_ptr离开作用域时，指向的对象会自动销毁</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>weakptr.lock() 方法尝试从其所关联的shared_ptr创建一个实例，如果袁术的shared_ptr 仍然存在(管理的对象还没被销毁)， lock() 方法会成功返回一个指向该对象的shared_ptr。如果原始的shared_ptr已经被销毁，lock()会返回一个空的shared_ptr。</p><h6 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h6><blockquote><ol><li>尽量使用智能指针来管理内存；</li><li>如果没有多个所有者共享对象的需求，建议优先使用unique_ptr管理内存，相对于 shared_ptr更轻量；</li><li>在使用shared_ptr时，一定要注意是否有循环引用的问题，会导致内存泄漏；</li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>cpp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>move</title>
    <link href="/2024/10/06/move/"/>
    <url>/2024/10/06/move/</url>
    
    <content type="html"><![CDATA[<h5 id="c-中move有什么作用，原理是什么"><a href="#c-中move有什么作用，原理是什么" class="headerlink" title="c++中move有什么作用，原理是什么"></a>c++中move有什么作用，原理是什么</h5><p>move 是c++11引入的一个新特性，用来实现移动语义。主要作用是将对象的资源从一个对象转移到另一个对象，而无需进行深拷贝，减少了资源内存的分配，可以提高性能。</p><h6 id="1）move-转换成右值有什么好处"><a href="#1）move-转换成右值有什么好处" class="headerlink" title="1）move 转换成右值有什么好处"></a>1）move 转换成右值有什么好处</h6><p>右值可以触发移动语义。移动语义：可以理解为在对象转换的时候，通过右值可以触发到类的移动构造函数或者移动赋值函数。<br>因为触发了移动构造函数或者移动赋值函数，默认原对象不会再使用了，包括某些内存。这样我们可以在新对象中直接使用原对象的那部分内存，减少了数据的拷贝操作，昂贵的拷贝转换为了廉价的移动，提升了程序的性能。</p><h6 id="2）std-move-后的对象还能够使用吗？"><a href="#2）std-move-后的对象还能够使用吗？" class="headerlink" title="2）std::move 后的对象还能够使用吗？"></a>2）std::move 后的对象还能够使用吗？</h6><p>取决于搭配的移动构造函数和移动赋值构造函数时如何实现的。如果在上述两个函数中，还是使用了拷贝的动作，那原对象还是可以使用的。<br>能够使用的示例代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>()&#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;A()&quot;</span>&lt;&lt;std::endl;<br>    &#125;<br>    ~<span class="hljs-built_in">A</span>()&#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;~A()&quot;</span>&lt;&lt;std::endl;<br>    &#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; a)&#123;<br>        count_=a.count_;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;A copy&quot;</span>&lt;&lt;std::endl;<br>    &#125;<br>    A&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> A&amp; a)&#123;<br>        count_=a.count_;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;A=&quot;</span>&lt;&lt;std::endl;<br>    &#125;<br>    <span class="hljs-built_in">A</span>(A&amp;&amp; a)&#123;<br>        count_=a.count_;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;A move&quot;</span>&lt;&lt;std::endl;<br>    &#125;<br>    A&amp; <span class="hljs-keyword">operator</span>=(A&amp;&amp;a)&#123;<br>        count_=a.count_;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;A move =&quot;</span>&lt;&lt;std::endl;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br><br>    &#125;<br>    std::string count_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A a;<br>    a.count_=<span class="hljs-string">&quot;12345&quot;</span>;<br>    A b=std::<span class="hljs-built_in">move</span>(a);<br>    std::cout&lt;&lt;a.count_&lt;&lt;std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果在移动构造函数和移动赋值函数中，将原对象的内存废弃掉，新对象使用原对象的内存，那原对象的内存就不可以使用了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">A</span>(A&amp;&amp;a)<br>&#123;<br>    count_=std::<span class="hljs-built_in">move</span>(a.count_);<br>&#125;<br>A&amp; <span class="hljs-keyword">operator</span>=(A&amp;&amp; a)<br>&#123;<br>    count_=std::<span class="hljs-built_in">move</span>(a.count_);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><ol><li>std::move 函数的作用是将参数强制转换为右值，只是转换为右值，不会对对象进行任何操作。</li><li>转换右值可以触发移动语义，减少数据的拷贝操作，提升程序的性能。</li><li>在使用std::move 函数后，原对象是否可以继续使用取决于移动构造函数和移动赋值函数的实现。</li></ol>]]></content>
    
    
    <categories>
      
      <category>cpp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>左值与右值</title>
    <link href="/2024/10/06/%E5%B7%A6%E5%80%BC%E4%B8%8E%E5%8F%B3%E5%80%BC/"/>
    <url>/2024/10/06/%E5%B7%A6%E5%80%BC%E4%B8%8E%E5%8F%B3%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h5 id="什么是左值，什么是右值"><a href="#什么是左值，什么是右值" class="headerlink" title="什么是左值，什么是右值"></a>什么是左值，什么是右值</h5><p><strong>左值</strong>：可以出现在赋值运算符的左边，并且可以被取地址，通常是有名字的变量。<br><strong>右值</strong>: 不能出现在赋值运算符的左边，不可以被取地址， 表示一个具体的数据值，通常是常量、临时变量。</p><p><strong>区分</strong>：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">左值：可以放在等号左边的值<br>右值：不可以放在等号左边的值<br><br>左值：可以被取地址并且有名字的值<br>右值：不能取地址的没有名字的<br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a=b+c；<br></code></pre></td></tr></table></figure><p>a 是左值，有变量名，可以取地址，也可以放在等号左边；<br>a+b 是右值，没有名字且不能取地址， &amp;（b+c） 不能通过编译，并且也不能放在等号左边。</p><p><strong>左值引用</strong>：等号右边的值必须可以取地址，如果不能取地址，会编译失败。或者可以使用const引用形式，但是只能通过引用读取输出，不能修改，因为是常量引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a=<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> &amp;b=a;<span class="hljs-comment">//b 是左值引用</span><br>b=<span class="hljs-number">4</span>;<br><span class="hljs-type">int</span> &amp;c=<span class="hljs-number">10</span>；<span class="hljs-comment">//error, 10无法取地址，无法进行引用</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;d=<span class="hljs-number">10</span>；<span class="hljs-comment">//ok,因为是常量引用，引用常数字，会存储在内存中，可以取地址</span><br></code></pre></td></tr></table></figure><p><strong>右值引用</strong><br>可以理解为对右值的引用，即<strong>对一个临时对象或者即将销毁的对象的引用</strong>，开发者可以利用这些临时对象，却不需要复制他们。<br>如果使用右值引用，那表达式右边的值需要时右值，可以使用std::move 函数强制将左值转换为右值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a=<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> &amp;&amp;b=a;<span class="hljs-comment">//error a是左值</span><br><span class="hljs-type">int</span> &amp;&amp;c=std:<span class="hljs-built_in">move</span>(a);<br></code></pre></td></tr></table></figure><p><strong>左值引用和右值引用的使用场景</strong><br>左值引用：当需要修改对象的值，或者需要引用一个持久对象时使用；<br>右值引用：当需要处理一个临时对象，并且想要避免复制，或者实现移动语义时使用。</p><p><strong>纯右值</strong><br>运算表达式产生的临时变量，不和对象关联的原始字面量，非引用返回的临时变量、lamba表达式等都是纯右值。<br><strong>将亡值</strong><br>c++11 新增的和右值引用相关的表达式，通常指将要被移动的对象，T&amp;&amp;函数的返回值，std::move 函数的返回值、转换为T&amp;&amp;类型转换函数的返回值。</p><p>将亡值可以了理解为将要销毁的值，通过“盗取”其他变量内存空间方式获取的值，在确保其他变量不再被使用或者即将销毁时，可以避免内存空间的释放和分配、延长变量值的生命周期，常用来完成移动构造或者移动复制的特殊任务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;&#125;;<br>A a;<br><span class="hljs-keyword">auto</span> c=std::<span class="hljs-built_in">move</span>(a);<span class="hljs-comment">//std::move(a)是将亡值</span><br><span class="hljs-keyword">auto</span> d= <span class="hljs-built_in">static_cast</span>&lt;A&amp;&amp;&gt;(a);<span class="hljs-comment">//static_cast&lt;A&amp;&amp;&gt;（a） 是将亡值。</span><br></code></pre></td></tr></table></figure><h6 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h6><p>为了实现转移语义和完美转发，消除两个对象交互式不必要的对象拷贝，也能够更加简洁明确的定义泛型函数。</p>]]></content>
    
    
    <categories>
      
      <category>cpp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
